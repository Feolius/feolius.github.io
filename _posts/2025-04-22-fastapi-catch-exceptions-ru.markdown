---
layout: post
title:  "Как поймать все исключения в Fastapi"
date:   2025-04-22
categories: ru
tags: "python fastapi"
---

## Дисклеймер
Информация ниже приведена для Fastapi v0.115.5

## Проблематика
Допустим мы хотим поймать все исключения, которые могут быть выброшены в обработчиках запросов в Fastapi. Это может 
быть необходимо когда нам надо
1. Залогировать все исключения (обязательно со стэктрейсом)
2. Гарантировать единый формат ответов для любых ошибок

Представим, что у нас есть функция вида
```python
def error_to_response(error: Exception) -> ErrorResponse:
    """
    This function logs error and convert error to response
    """
    pass
```
Она уже написана, и она логирует ошибку и возвращает ответ, который мы можем слать клиенту. Тогда код в обработчике
будет выглядеть так
```python
@app.get("/ping")
async def ping():
    try:
        # Here is all the path operator code
        return do_ping()
    except Exception as e:
        return error_to_response(e)
```
Таким образом, в каждом обработчике у нас будет `try - except`, который должен оборачивать весь код обработчика. 
Бойлерплейтно? Еще как! Попробуем избавиться от этого блока. 

Далее я расскажу о моем конкретном пути достижения этой цели в том порядке, в котором я пробовал различные варианты.

## Что предлагает Fastapi

В Fastapi существует [документация](https://fastapi.tiangolo.com/tutorial/handling-errors/), посвященная обработке 
ошибок. В ней показано, что для любого кастомного типа исключений можно навешать собственный обработчик
```python
class UnicornException(Exception):
    def __init__(self, name: str):
        self.name = name

@app.exception_handler(UnicornException)
async def unicorn_exception_handler(request: Request, exc: UnicornException):
    return JSONResponse(
        status_code=418,
        content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
    )
```

Отсюда идея: навешаем обработчик на базовый Exception. Такой обработчик будет ловить все исключения, потому что любое 
исключение наследуется от базового.
```python
@app.exception_handler(Exception)
async def exc_handler(request: Request, e: Exception) -> JSONResponse:
    return error_to_response(e)
```

И это сработает! Правда с одним большим и одним маленьким минусом.

### Большой минус

На практике оказалось, что обработчик базового типа `Exception` у Fastapi ~~захардкожен~~ зарезервирован на случай,
когда никакие другие обработчики не сработали. То есть это случай _unhandled exception_, и его обрабатывает Fastapi,
но делается это в самый последний момент перед отправкой ответа. 

Этот обработчик существует по-умолчанию, и он возвращает 500 ошибку. Нашим кодом, мы просто переопределили его. И это
сработало. Но мы хотим залогировать стэктрейс ошибки. И его раскрутка до обработчика приводит к тому, что мы видим
в логах более 30 внутренних вызовов Fastapi, которые никакого отношения к нашей бизнес логике не имеют. Это просто
засорение логов.

### Маленький минус

В Fastapi существуют два "встроенных" обработчика для исключений `HTTPException` и `RequestValidationError`. 
И если эти исключения выбрасываются, то они не попадают в наш обработчик. Вместо этого они обрабатываются собственными 
обработчиками. Эти обработчики можно лишь переопределить, но нельзя полностью выключить.







